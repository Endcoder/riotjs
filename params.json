{"name":"Riotjs","tagline":"","body":"#Tutorial: RIOT.JS\r\n\r\n##Einleitung\r\n\r\nRIOT.JS ist eine Javascript Bibliothek, die es ermöglicht Webanwendungen\r\nnach dem Model-View-Presenter Konzept (kurz: MVP) zu entwickeln. Dies\r\nerlaubt es große Anwendungen modular aufzubauen, und so die Übersichtlichkeit\r\nzu bewahren.\r\n\r\nRIOT.JS zeichnet sich vor allem durch seine Größe aus, denn der minimierte\r\nQuelltext ist lediglich 1.6kb groß. Die folgende Übersicht zeigt, wie klein\r\ndiese Bibliothek im Vergleich zu anderen wirklich ist:\r\n\r\n<img src=\"https://muut.com/m/img/riotjs/riot-size-1.6kb.png\" />\r\n\r\n\r\nDes Weiteren basiert RIOT.JS auf Vanilla Javascript, also purem\r\nJavascript, wodurch eine Abhängigkeit zu anderen Frameworks ausgeschlossen wird.\r\n\r\nBestandteil von RIOT.JS ist eine Template Engine, die es erlaubt HTML Templates\r\nzu bauen und zu rendern, eine Event Libraray, die die Kommunikation und Callbacks\r\nermöglicht, und eine Routerfunktion, um die Navigation zu ermöglichen.\r\n\r\n##MVP\r\n\r\nDas MVP-Pattern ist dem Model-View-Controller Pattern sehr ähnlich,\r\nunterscheidet sich jedoch darin, dass es statt einem Controller einen Presenter\r\ngibt. Im MVC Pattern konnten die einzelnen Komponen direkt miteinander interagieren,\r\nim MVP Pattern ist dies nicht möglich.\r\n\r\nHier übernimmt der Presenter die Kommunikation zwischen View und Model in beide\r\nRichtungen. Hieraus resultiert eine strikte Trennung von View und Model, wodurch\r\ndas Testen des Views mit Hilfe von Unit Tests ermöglicht wird.\r\n\r\n* Model\r\n\r\nDas Model kennt weder den Presenter, noch den View und modelliert die Geschäftslogik.\r\nD.h. hier ist die Struktur der Daten modelliert, und die grundlegende Logik implementiert.\r\n\r\n* View\r\n\r\nIm View wird lediglich die Oberfläche dargestellt, und es ist lediglich für die Darstellung\r\nder Ein- und Ausgaben zuständig. Die Steuerung des Views erfolgt ausschließlich\r\nvom Presenter, in dem dieser auf Events des Views lauscht.\r\n\r\n* Presenter\r\n\r\nDer Presenter ist das Bindeglied zwischen Model und View. Er übernimmt die gesamte Steuerung,\r\nalso sowohl der Oberfläche, als auch der Logik, und sorgt für Kommunikation zwischen Model\r\nund View. \r\n\r\n##Methoden\r\n\r\nUm Webanwendungen nach dem MVP Pattern mit Hilfe von Riot.JS zu entwickeln, werden\r\nlediglich wenige Methoden benötigt. Hier zu zählen:\r\n* riot.observable(element)\r\n\r\nDie Observable Methode erlaubt es dem gewählten Objekt die Event-basierte Kommunikation\r\nzu nutzen, d.h. es können Events gefeuert und auf diese gelauscht werden.\r\n```Javascript\r\nfunction Car() {\r\n \r\n  // Make Car instances observable\r\n  var self = riot.observable(this);\r\n \r\n  // listen to \"start\" event\r\n  self.on(\"start\", function() {\r\n    // engine started\r\n  });\r\n}\r\n \r\n// make a new Car instance\r\nvar car = new Car();\r\n \r\n// trigger \"start\" event\r\ncar.trigger(\"start\")\r\n```\r\n* riot.trigger(event[, arguments])\r\n\r\nDie Trigger Methode erlaubt es einem Objekt Events zu feuern. Hierdurch\r\nkann die Kommunikation zwischen Model und Presenter realisiert werden.\r\n```Javascript\r\nel.trigger(\"start\");\r\n```\r\n* riot.on(event, callback)\r\n \r\nDie On-Methode bindet eine Funktion an ein Event, um so den Callback zu ermöglichen.\r\nD.h. wenn beispielsweise das Model ein Event feuert, kann der Presenter mit Hilfe\r\nder On-Methode auf dieses reagieren.\r\n```Javascript\r\n// listen to single event\r\nel.on(\"start\", function() {\r\n \r\n});\r\n \r\n// listen to multiple events, the event type is given as the argument\r\nel.on(\"start stop\", function(type) {\r\n \r\n  // type is either \"start\" or \"stop\"\r\n \r\n});\r\n```\r\n\r\n* riot.render(template, data)\r\n\r\nDie Render Methode nutzt ein vorgebenen HTML-Template, um dieses mit Hilfe der gegebenen\r\nDaten zu rendern. Somit werden Platzhalter in dem Template durch die gewünschten Daten\r\nersetzt und auf der Oberfläche dargestellt.\r\n\r\n```JavaScript\r\n// returns: \"<h1>Hello Testuser</h1>\"\r\nriot.render(\"<h1>Hello {username}</h1>\", { username: 'Testuser' });\r\n\r\n```\r\n\r\n## Beispiel: TODO Liste\r\n\r\nUnter <a href=\"http://www.3den.org/riotjs-todomvc/\">diesem Link</a> ist eine Beispielanwendung\r\nzu finden, die eine TODO-Liste mit Hilfe von RIOT.JS zeigt.\r\n\r\nIm folgenden soll mit Hilfe von relevanten Quelltextausschnitten die Funktionsweise erläutert werden.\r\nDies geschieht am Beispiel des Hinzufügens einer neuen Aufgabe.\r\n\r\nZunächst wird im View ein neues Template definiert, welches den Aufbau und das Aussehen eines neuen Eintrages\r\ndefiniert:\r\n```HTML\r\n<template id=\"task-template\">\r\n      <li id=\"task_{id}\" data-task=\"{id}\">\r\n        <div class=\"view todo-task\">\r\n          <input class=\"toggle\" type=\"checkbox\">\r\n          <label>{name}</label>\r\n          <button class=\"destroy\"/>\r\n        </div>\r\n        <input class=\"edit\" value=\"{name}\">\r\n      </li>\r\n</template>\r\n```\r\n\r\nAnschließend wird im Model ein Objekt erzeugt, welches der Observermethode übergeben wird, um \r\ndas Nutzen von Events zu ermöglichen. Für das Persistieren der Aufgaben wird der Local Storage\r\ndes Browsers genutzt, welcher in diesem Fall über das \"DB\"-Objekt erreichbar ist.\r\n```JavaScript\r\nfunction Todo() {\r\n    var self = $.observable(this),\r\n        db = DB('riot-todo'),\r\n        items = db.get();\r\n\r\n    self.add = function(name, done) {\r\n        var item = {\r\n          id: generateId(), name: name, done: done\r\n        };\r\n\r\n        items[item.id] = item;\r\n        self.trigger('add', item);\r\n    };\r\n\t\r\n\t// sync database\r\n    self.on('add remove toggle edit', function() {\r\n        db.put(items);\r\n    });\r\n\r\n\t//  hier können weitere Funktionen definiert werden\r\n}\r\n```\r\n\r\nDie Add-Methode generiert ein neues Objekt mit der übergebenen\r\nAufgabe, und generiert eine eindeutige ID. Anschließend wird\r\ndas \"Add\" Event getriggert und gleichzeitig das erzeugte Objekt\r\nübergeben.\r\nDurch die on-Methode wird auf dieses Event gelauscht und der Eintrag persistiert.\r\n\r\nIm folgenden wird der Presenter definiert. Dieser muss zum einen darauf lauschen,\r\nob in dem Eingabefeld die Entertaste gedrückt wurde, um in diesem Fall die Eingaben\r\nan das Model weiterzuleiten.\r\nIst dies erledigt, muss der Presenter auf das \"add\"-Event des Models reagieren\r\nund das Objekt nach Vorgabe des Templates rendern:\r\n\r\n```JavaScript\r\nfunction todoPresenter(element, options) {\r\n    element = $(element);\r\n    var template = options.template,\r\n        todo = options.model,\r\n        $list = element.find('#todo-list'),\r\n        ENTER_KEY = 13,\r\n        ESC_KEY = 27;\r\n\r\n    /* Listen to user events */\r\n\r\n    element.on('keyup', '#new-todo', function(e) { // wenn Taste in Eingabefeld gedrückt\r\n        var val = $.trim(this.value);\r\n        if (val && e.which === 13) {  // wenn Enter-Taste gedrückt\r\n            todo.add(val);\t\t\t  // rufe Model auf, um Objekt anzulegen\r\n            this.value = '';\t\t  // leere Eingabefeld\r\n        }\r\n\t}\r\n\t\r\n\t/* Listen to model events */\r\n\t\r\n\ttodo.on('add', function(item){\r\n        $(\"#main\", element).show();\r\n        var task = $($.render(template, item));\r\n        $list.append(task);\r\n        toggle(task, !!item.done);\r\n    });\r\n```\r\n\r\nZuletzt müssen die einzelnen Komponenten initialisiert werden:\r\n\r\n```JavaScript\r\n(function ($) {\r\n    var todo = new Todo();\r\n    routes({todo: todo});\r\n\r\n    // Binds the Todo Presenter\r\n    todoPresenter($(\"#todoapp\"), {\r\n        model: todo,\r\n        template: $('#task-template').html(),\r\n    });\r\n\r\n    // Binds the Footer Presenter\r\n    footerPresenter($(\"#footer\"), {\r\n        model: todo,\r\n        template: $('#footer-template').html(),\r\n    });\r\n})(jQuery);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}